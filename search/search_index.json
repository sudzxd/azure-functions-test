{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"azure-functions-test","text":"<p>Unit test Azure Functions without the runtime.</p> <p>Fast, ergonomic, type-safe mock objects for testing Azure Functions. No runtime, no Azurite, no boilerplate.</p> <p> </p>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from azure_functions_test import mock_queue_message, FunctionTestContext\n\ndef test_process_order():\n    # Arrange\n    msg = mock_queue_message({\"order_id\": 123, \"customer\": \"Alice\"})\n    ctx = FunctionTestContext()\n\n    # Act\n    process_order(msg, ctx.out(\"result\"))\n\n    # Assert\n    assert ctx.outputs[\"result\"][\"status\"] == \"completed\"\n    assert ctx.outputs[\"result\"][\"order_id\"] == 123\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>6 Trigger Types Supported: Queue Storage, HTTP, Timer, Blob Storage, Service Bus, Event Grid</li> <li>Zero Runtime Dependency: Pure Python mocks using Pydantic - no <code>func start</code>, Azurite, or Docker needed</li> <li>Type-Safe: Full Pyright strict mode coverage (0 errors) with auto-complete support</li> <li>SDK-Compatible: Drop-in replacements for <code>azure-functions</code> types with all methods and properties</li> <li>Minimal Ceremony: Simple factory functions with smart defaults - only specify data you care about</li> <li>Output Capture: Explicit output binding capture with <code>FunctionTestContext</code> for type-safe assertions</li> <li>Fast: Tests run in milliseconds, not seconds</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install azure-functions-test\n</code></pre> <p>For development:</p> <pre><code>git clone https://github.com/sudzxd/azure-functions-test\ncd azure-functions-test\nuv sync --all-extras\n</code></pre>"},{"location":"#versioning","title":"Versioning","text":"<p>This package follows version-compatible versioning with the <code>azure-functions</code> library.</p> <p>See CHANGELOG for version history and compatibility details.</p> <p>Requirements: - Python: <code>3.11+</code> - Azure Functions: <code>&gt;=1.17.0</code> - Pydantic: <code>&gt;=2.0</code></p>"},{"location":"#why-this-library","title":"Why This Library?","text":"Current Approach Problem <code>func start</code> + Azurite Slow (5-10s startup), flaky, requires Docker Manual mocking Tedious boilerplate, inconsistent across projects Integration tests only Slow feedback loop, hard to test edge cases No testing Bugs in production <p>This library fills the gap: Fast, ergonomic mocks with output capture and zero runtime dependency.</p>"},{"location":"#supported-triggers","title":"Supported Triggers","text":""},{"location":"#queue-storage","title":"Queue Storage","text":"<pre><code>from azure_functions_test import mock_queue_message\n\n# Simple message\nmsg = mock_queue_message({\"order_id\": 123})\nassert msg.get_json()[\"order_id\"] == 123\n\n# With metadata\nmsg = mock_queue_message(\n    b\"raw data\",\n    id=\"msg-456\",\n    dequeue_count=3,\n    insertion_time=datetime(2025, 1, 1, tzinfo=UTC)\n)\n</code></pre>"},{"location":"#http-request","title":"HTTP Request","text":"<pre><code>from azure_functions_test import mock_http_request\n\n# JSON request\nreq = mock_http_request(\n    method=\"POST\",\n    body={\"name\": \"Alice\"},\n    headers={\"Content-Type\": \"application/json\"}\n)\n\n# Form data (auto-parsed)\nreq = mock_http_request(\n    method=\"POST\",\n    body=\"name=Alice&amp;age=30\",\n    headers={\"Content-Type\": \"application/x-www-form-urlencoded\"}\n)\nassert req.form[\"name\"] == \"Alice\"\n\n# With route params\nreq = mock_http_request(\n    url=\"/api/users/123\",\n    route_params={\"id\": \"123\"}\n)\n</code></pre>"},{"location":"#timer-trigger","title":"Timer Trigger","text":"<pre><code>from azure_functions_test import mock_timer_request\nfrom datetime import datetime, UTC\n\n# Simple timer\ntimer = mock_timer_request()\n\n# With schedule and past-due tracking\ntimer = mock_timer_request(\n    schedule={\"AdjustForDST\": True},\n    schedule_status={\"Last\": datetime(2025, 1, 1, 12, 0, 0, tzinfo=UTC)},\n    past_due=True\n)\n</code></pre>"},{"location":"#blob-storage","title":"Blob Storage","text":"<pre><code>from azure_functions_test import mock_blob\n\n# Simple blob\nblob = mock_blob(b\"file contents\", name=\"data.txt\")\nassert blob.read() == b\"file contents\"\n\n# With metadata and properties\nblob = mock_blob(\n    b\"image data\",\n    name=\"photo.jpg\",\n    uri=\"https://mystorageaccount.blob.core.windows.net/images/photo.jpg\",\n    metadata={\"author\": \"Alice\", \"version\": \"1.0\"},\n    blob_properties={\"ContentType\": \"image/jpeg\"}\n)\n</code></pre>"},{"location":"#service-bus","title":"Service Bus","text":"<pre><code>from azure_functions_test import mock_service_bus_message\n\n# Simple message\nmsg = mock_service_bus_message({\"order_id\": 123})\nassert msg.get_body() == b'{\"order_id\": 123}'\n\n# Session-based message\nmsg = mock_service_bus_message(\n    {\"step\": 1, \"data\": \"workflow\"},\n    message_id=\"msg-session-1\",\n    session_id=\"workflow-123\",\n    sequence_number=1\n)\n\n# Dead-lettered message\nmsg = mock_service_bus_message(\n    b\"failed message\",\n    dead_letter_source=\"orders-queue\",\n    dead_letter_reason=\"ProcessingException\",\n    delivery_count=10\n)\n</code></pre>"},{"location":"#event-grid","title":"Event Grid","text":"<pre><code>from azure_functions_test import mock_event_grid_event\n\n# Custom event\nevent = mock_event_grid_event(\n    data={\"order_id\": 123, \"status\": \"pending\"},\n    event_type=\"myapp.order.created\",\n    subject=\"orders/123\"\n)\n\n# Azure system event (Blob Created)\nevent = mock_event_grid_event(\n    data={\n        \"api\": \"PutBlob\",\n        \"contentType\": \"application/json\",\n        \"url\": \"https://mystorageaccount.blob.core.windows.net/...\",\n    },\n    event_type=\"Microsoft.Storage.BlobCreated\",\n    subject=\"/blobServices/default/containers/data/blobs/file.json\",\n    topic=\"/subscriptions/.../storageAccounts/...\"\n)\n</code></pre>"},{"location":"#output-bindings","title":"Output Bindings","text":"<p>Capture output bindings with <code>FunctionTestContext</code>:</p> <pre><code>from azure_functions_test import FunctionTestContext\n\ndef test_function_with_output():\n    # Arrange\n    ctx = FunctionTestContext()\n\n    # Act - pass ctx.out(\"binding_name\") to your function\n    my_function(input_data, ctx.out(\"queue\"), ctx.out(\"blob\"))\n\n    # Assert on outputs\n    assert ctx.outputs[\"queue\"][\"message\"] == \"processed\"\n    assert ctx.outputs[\"blob\"] == b\"result data\"\n\n    # Check if output was set\n    assert ctx.is_set(\"queue\")\n    assert ctx.is_set(\"blob\")\n</code></pre>"},{"location":"#real-world-example","title":"Real-World Example","text":"<pre><code>import azure.functions as func\nfrom azure_functions_test import (\n    mock_service_bus_message,\n    FunctionTestContext\n)\n\ndef process_order(msg: func.ServiceBusMessage, blob_out: func.Out[bytes]):\n    \"\"\"Process order from Service Bus and write receipt to Blob.\"\"\"\n    order = msg.get_json()\n\n    # Business logic\n    receipt = {\n        \"order_id\": order[\"order_id\"],\n        \"processed_at\": datetime.now(UTC).isoformat(),\n        \"status\": \"completed\"\n    }\n\n    # Write to blob output binding\n    blob_out.set(json.dumps(receipt).encode())\n\n# Test\ndef test_process_order():\n    # Arrange\n    msg = mock_service_bus_message(\n        {\"order_id\": 12345, \"customer_id\": 67890},\n        message_id=\"order-12345\",\n        session_id=\"customer-67890\"\n    )\n    ctx = FunctionTestContext()\n\n    # Act\n    process_order(msg, ctx.out(\"receipt\"))\n\n    # Assert\n    receipt = json.loads(ctx.outputs[\"receipt\"])\n    assert receipt[\"order_id\"] == 12345\n    assert receipt[\"status\"] == \"completed\"\n    assert \"processed_at\" in receipt\n</code></pre>"},{"location":"#api-reference","title":"API Reference","text":""},{"location":"#mock-factory-functions","title":"Mock Factory Functions","text":"<p>All factory functions follow the same pattern:</p> <pre><code>mock_&lt;trigger_name&gt;(\n    body_or_data,           # Positional: main data\n    *,                      # Keyword-only args\n    trigger_specific_args   # e.g., message_id, session_id, etc.\n)\n</code></pre> Function Description <code>mock_queue_message()</code> Create Queue Storage message <code>mock_http_request()</code> Create HTTP request <code>mock_timer_request()</code> Create Timer trigger <code>mock_blob()</code> Create Blob input stream <code>mock_service_bus_message()</code> Create Service Bus message <code>mock_event_grid_event()</code> Create Event Grid event <p>See the API Reference for detailed documentation of each function.</p>"},{"location":"#functiontestcontext","title":"FunctionTestContext","text":"<pre><code>class FunctionTestContext:\n    def out(self, name: str) -&gt; Out[T]:\n        \"\"\"Get output binding by name.\"\"\"\n\n    @property\n    def outputs(self) -&gt; dict[str, Any]:\n        \"\"\"Get all captured outputs.\"\"\"\n\n    def is_set(self, name: str) -&gt; bool:\n        \"\"\"Check if output binding was set.\"\"\"\n</code></pre> <p>See the Context API documentation for more details.</p>"},{"location":"#design-principles","title":"Design Principles","text":"<ol> <li>Zero Runtime Dependency - No Azure Functions runtime or Azurite required</li> <li>Structural Typing - Uses Protocol types for duck-typed compatibility with Azure SDK</li> <li>Minimal Ceremony - Only specify data you care about, sensible defaults for the rest</li> <li>Explicit Over Implicit - Output bindings captured explicitly, no magic</li> <li>Fail Fast, Fail Clear - Type errors caught at test time with clear messages</li> </ol>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions welcome! Please read the Contributing Guide.</p> <p>Development Setup:</p> <pre><code>git clone https://github.com/sudzxd/azure-functions-test\ncd azure-functions-test\nuv sync --all-extras\nPYTHONPATH=src uv run pytest\n</code></pre> <p>Run all checks:</p> <pre><code>uv run ruff check .              # Linting\nPYTHONPATH=src uv run pyright    # Type checking\nPYTHONPATH=src uv run pytest     # Tests with coverage\n</code></pre>"},{"location":"#status","title":"Status","text":"<p>See CHANGELOG for release history.</p> <ul> <li>203 tests passing</li> <li>75.94% code coverage</li> <li>Pyright strict mode: 0 errors</li> <li>All 6 core trigger types fully implemented</li> </ul>"},{"location":"#license","title":"License","text":"<p>Distributed under the MIT License. See LICENSE for more information.</p>"},{"location":"#links","title":"Links","text":"<ul> <li>Repository: github.com/sudzxd/azure-functions-test</li> <li>PyPI: pypi.org/project/azure-functions-test</li> <li>Issues: GitHub Issues</li> </ul> <p>\u2b50 Star this repo to follow progress!</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Quick guide to set up and write your first test with <code>azure-functions-test</code>.</p>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#development-setup","title":"Development Setup","text":"<pre><code>git clone https://github.com/sudzxd/azure-functions-test\ncd azure-functions-test\nuv sync --all-extras\n</code></pre>"},{"location":"getting-started/#using-in-your-project-coming-soon","title":"Using in Your Project (Coming Soon)","text":"<pre><code>pip install azure-functions-test\n</code></pre>"},{"location":"getting-started/#your-first-test","title":"Your First Test","text":""},{"location":"getting-started/#1-write-a-simple-azure-function","title":"1. Write a Simple Azure Function","text":"<pre><code># my_function.py\nimport azure.functions as func\n\ndef main(msg: func.QueueMessage) -&gt; None:\n    data = msg.get_json()\n    print(f\"Processing order {data['order_id']}\")\n</code></pre>"},{"location":"getting-started/#2-write-a-test","title":"2. Write a Test","text":"<pre><code># test_my_function.py\nfrom azure_functions_test import mock_queue_message\nfrom my_function import main\n\ndef test_process_order():\n    # Arrange\n    msg = mock_queue_message({\"order_id\": 123})\n\n    # Act\n    main(msg)\n\n    # Assert\n    assert msg.get_json()[\"order_id\"] == 123\n</code></pre>"},{"location":"getting-started/#3-run-tests","title":"3. Run Tests","text":"<pre><code>pytest test_my_function.py\n</code></pre> <p>That's it! No runtime, no Azurite, just fast unit tests.</p>"},{"location":"getting-started/#testing-with-output-bindings","title":"Testing with Output Bindings","text":"<pre><code>from azure_functions_test import FunctionTestContext, mock_queue_message\n\ndef test_with_output():\n    # Create test context for output capture\n    ctx = FunctionTestContext()\n    msg = mock_queue_message({\"order_id\": 456})\n\n    # Run function\n    process_order(msg, ctx)\n\n    # Verify output binding was set\n    output = ctx.get_output(\"receipt_queue\")\n    assert output[\"order_id\"] == 456\n</code></pre>"},{"location":"getting-started/#common-test-patterns","title":"Common Test Patterns","text":""},{"location":"getting-started/#parametrized-tests","title":"Parametrized Tests","text":"<pre><code>import pytest\n\n@pytest.mark.parametrize(\"status,expected\", [\n    (\"pending\", \"process\"),\n    (\"cancelled\", \"skip\"),\n])\ndef test_order_statuses(status, expected):\n    msg = mock_queue_message({\"status\": status})\n    result = handle_order(msg)\n    assert result == expected\n</code></pre>"},{"location":"getting-started/#error-handling","title":"Error Handling","text":"<pre><code>def test_invalid_json():\n    msg = mock_queue_message(\"not json\")\n\n    with pytest.raises(ValueError):\n        process_message(msg)\n</code></pre>"},{"location":"getting-started/#edge-cases","title":"Edge Cases","text":"<pre><code>def test_poison_message():\n    # Simulate message that's been dequeued 6+ times\n    msg = mock_queue_message({\"data\": \"test\"}, dequeue_count=6)\n\n    result = handle_message(msg)\n    assert result[\"action\"] == \"move_to_dead_letter\"\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>API Reference - Complete documentation for all mocks</li> <li>Examples - Real-world usage examples</li> <li>Style Guide - Contribution guidelines</li> </ul>"},{"location":"getting-started/#all-available-mocks","title":"All Available Mocks","text":"Trigger Type Mock Function Documentation Queue Storage <code>mock_queue_message()</code> Mocks API HTTP <code>mock_http_request()</code> Mocks API Timer <code>mock_timer_request()</code> Mocks API Blob Storage <code>mock_blob()</code> Mocks API Service Bus <code>mock_service_bus_message()</code> Mocks API Event Grid <code>mock_event_grid_event()</code> Mocks API"},{"location":"getting-started/#development-commands","title":"Development Commands","text":"<pre><code># Run all tests\nPYTHONPATH=src pytest\n\n# Type checking\nPYTHONPATH=src pyright\n\n# Format code\nruff format .\n\n# Lint\nruff check .\n</code></pre>"},{"location":"api/","title":"API Reference","text":"<p>Complete reference documentation for <code>azure-functions-test</code>.</p>"},{"location":"api/#quick-navigation","title":"Quick Navigation","text":"API Category Description Documentation Mock Functions Create test doubles for Azure Functions triggers Mocks API Test Context Capture and assert on output bindings Context API Protocols Type definitions for structural typing Protocols"},{"location":"api/#core-concepts","title":"Core Concepts","text":""},{"location":"api/#mocks","title":"Mocks","text":"<p>Mocks are factory functions that create test doubles for Azure Functions trigger inputs. Each mock:</p> <ul> <li>Returns an object implementing the corresponding Azure SDK protocol</li> <li>Accepts flexible input types with automatic serialization</li> <li>Provides sensible defaults for all optional parameters</li> <li>Is fully type-safe with Pyright strict mode</li> </ul> <p>Available mocks:</p> <ul> <li><code>mock_queue_message()</code> - Queue Storage triggers</li> <li><code>mock_http_request()</code> - HTTP triggers</li> <li><code>mock_timer_request()</code> - Timer triggers</li> <li><code>mock_blob()</code> - Blob Storage triggers</li> <li><code>mock_service_bus_message()</code> - Service Bus triggers</li> <li><code>mock_event_grid_event()</code> - Event Grid triggers</li> </ul> <p>\u2192 Full Mock API Reference</p>"},{"location":"api/#test-context","title":"Test Context","text":"<p><code>FunctionTestContext</code> captures output binding values during test execution, allowing you to:</p> <ul> <li>Register output bindings with <code>ctx.out(name)</code></li> <li>Assert on captured values via <code>ctx.outputs</code></li> <li>Check if optional outputs were set with <code>ctx.is_set(name)</code></li> </ul> <p>\u2192 Full Context API Reference</p>"},{"location":"api/#protocols","title":"Protocols","text":"<p>Protocol types provide structural typing for duck-typed mocks. Each protocol defines the interface that Azure Functions expects, allowing our mocks to be drop-in replacements without inheritance.</p> <p>\u2192 Full Protocols Reference</p>"},{"location":"api/#complete-api-index","title":"Complete API Index","text":""},{"location":"api/#mock-functions","title":"Mock Functions","text":"<pre><code>from azure_functions_test import (\n    mock_queue_message,\n    mock_http_request,\n    mock_timer_request,\n    mock_blob,\n    mock_service_bus_message,\n    mock_event_grid_event,\n)\n</code></pre> Function Returns Docs <code>mock_queue_message(body, *, id, dequeue_count, ...)</code> <code>QueueMessageProtocol</code> \u2192 <code>mock_http_request(body, *, method, url, headers, ...)</code> <code>HttpRequestProtocol</code> \u2192 <code>mock_timer_request(*, past_due)</code> <code>TimerRequestProtocol</code> \u2192 <code>mock_blob(content, *, name, uri)</code> <code>InputStreamProtocol</code> \u2192 <code>mock_service_bus_message(body, *, message_id, session_id, ...)</code> <code>ServiceBusMessageProtocol</code> \u2192 <code>mock_event_grid_event(*, data, id, event_type, ...)</code> <code>EventGridEventProtocol</code> \u2192"},{"location":"api/#context-classes","title":"Context Classes","text":"<pre><code>from azure_functions_test import FunctionTestContext, CapturedOutput\n</code></pre> Class Purpose Docs <code>FunctionTestContext</code> Capture output bindings in tests \u2192 <code>CapturedOutput[T]</code> Generic output capture with type safety \u2192"},{"location":"api/#protocol-types","title":"Protocol Types","text":"<pre><code>from azure_functions_test.protocols import (\n    QueueMessageProtocol,\n    HttpRequestProtocol,\n    TimerRequestProtocol,\n    InputStreamProtocol,\n    ServiceBusMessageProtocol,\n    EventGridEventProtocol,\n)\n</code></pre> Protocol Matches Azure SDK Type Docs <code>QueueMessageProtocol</code> <code>azure.functions.QueueMessage</code> \u2192 <code>HttpRequestProtocol</code> <code>azure.functions.HttpRequest</code> \u2192 <code>TimerRequestProtocol</code> <code>azure.functions.TimerRequest</code> \u2192 <code>InputStreamProtocol</code> <code>azure.functions.InputStream</code> \u2192 <code>ServiceBusMessageProtocol</code> <code>azure.functions.ServiceBusMessage</code> \u2192 <code>EventGridEventProtocol</code> <code>azure.functions.EventGridEvent</code> \u2192"},{"location":"api/#usage-example","title":"Usage Example","text":"<p>Here's a complete example showing all the main APIs:</p> <pre><code>from azure_functions_test import (\n    mock_queue_message,\n    mock_http_request,\n    FunctionTestContext,\n)\n\n\ndef test_order_processing_pipeline():\n    \"\"\"Test a multi-stage order processing function.\"\"\"\n\n    # === ARRANGE ===\n\n    # Create mock queue message with order data\n    order_msg = mock_queue_message({\n        \"order_id\": 123,\n        \"customer\": \"alice@example.com\",\n        \"items\": [\"laptop\", \"mouse\"],\n        \"total\": 1299.99\n    })\n\n    # Create mock HTTP request for webhook notification\n    webhook_req = mock_http_request(\n        body={\"order_id\": 123, \"status\": \"processing\"},\n        method=\"POST\",\n        url=\"https://example.com/webhook\",\n        headers={\"Content-Type\": \"application/json\"}\n    )\n\n    # Create test context to capture outputs\n    ctx = FunctionTestContext()\n\n    # === ACT ===\n\n    # Call function with mocks\n    process_order(\n        order_msg,\n        ctx.out(\"processed_orders\"),\n        ctx.out(\"customer_notifications\"),\n        ctx.out(\"error_log\")\n    )\n\n    send_webhook(webhook_req, ctx.out(\"webhook_response\"))\n\n    # === ASSERT ===\n\n    # Verify order was processed\n    assert ctx.is_set(\"processed_orders\")\n    processed = ctx.outputs[\"processed_orders\"]\n    assert processed[\"order_id\"] == 123\n    assert processed[\"status\"] == \"completed\"\n\n    # Verify customer was notified\n    assert ctx.is_set(\"customer_notifications\")\n    notification = ctx.outputs[\"customer_notifications\"]\n    assert notification[\"to\"] == \"alice@example.com\"\n\n    # Verify no errors occurred\n    assert not ctx.is_set(\"error_log\")\n\n    # Verify webhook succeeded\n    webhook_result = ctx.outputs[\"webhook_response\"]\n    assert webhook_result[\"status_code\"] == 200\n</code></pre>"},{"location":"api/#type-safety","title":"Type Safety","text":"<p>All APIs are fully typed for use with Pyright strict mode:</p> <pre><code>from azure_functions_test import mock_queue_message\nfrom azure_functions_test.protocols import QueueMessageProtocol\n\n# Type checker knows the return type\nmsg: QueueMessageProtocol = mock_queue_message({\"data\": \"test\"})\n\n# Autocomplete works\ndata = msg.get_json()  # \u2713 Type checker knows this method exists\nbody = msg.get_body()  # \u2713 Returns bytes\n\n# Type errors are caught\nmsg.invalid_method()  # \u2717 Type error: method doesn't exist\n</code></pre>"},{"location":"api/#next-steps","title":"Next Steps","text":"<ul> <li>Mock API Reference - Detailed docs for all mock functions</li> <li>Context API Reference - Testing context and output capture</li> <li>Protocols Reference - Protocol type definitions</li> <li>Examples - Real-world code samples</li> </ul>"},{"location":"api/context/","title":"Context API Reference","text":"<p>The Context API provides utilities for testing Azure Functions that use output bindings.</p>"},{"location":"api/context/#overview","title":"Overview","text":"<p>When testing Azure Functions, you often need to verify what data was written to output bindings (queues, blobs, tables, etc.). The <code>FunctionTestContext</code> class captures these outputs so you can assert against them in your tests.</p>"},{"location":"api/context/#functiontestcontext","title":"<code>FunctionTestContext</code>","text":"<p>A test context for capturing Azure Functions output bindings.</p>"},{"location":"api/context/#functiontestcontext-class-definition","title":"<code>FunctionTestContext</code> Class Definition","text":"<pre><code>class FunctionTestContext:\n    \"\"\"Test context for capturing Azure Functions output bindings.\"\"\"\n</code></pre>"},{"location":"api/context/#functiontestcontext-methods","title":"<code>FunctionTestContext</code> Methods","text":""},{"location":"api/context/#outname-str-capturedoutputany","title":"<code>out(name: str) -&gt; CapturedOutput[Any]</code>","text":"<p>Register an output binding and return a capture object.</p> <p><code>out()</code> Parameters:</p> <ul> <li><code>name</code> (<code>str</code>): Name of the output binding (matches function.json binding name)</li> </ul> <p><code>out()</code> Returns:</p> <ul> <li><code>CapturedOutput[Any]</code>: An output capture object that records the value when set</li> </ul> <p><code>out()</code> Example:</p> <pre><code>from azure_functions_test import FunctionTestContext\n\nctx = FunctionTestContext()\noutput = ctx.out(\"result\")\n\n# Pass to function\nmy_function(input_data, output)\n\n# Assert on captured value\nassert ctx.outputs[\"result\"] == expected_value\n</code></pre>"},{"location":"api/context/#is_setname-str-bool","title":"<code>is_set(name: str) -&gt; bool</code>","text":"<p>Check if an output binding has been set.</p> <p><code>is_set()</code> Parameters:</p> <ul> <li><code>name</code> (<code>str</code>): Name of the output binding</li> </ul> <p><code>is_set()</code> Returns:</p> <ul> <li><code>bool</code>: <code>True</code> if the output was set, <code>False</code> otherwise</li> </ul> <p><code>is_set()</code> Example:</p> <pre><code>ctx = FunctionTestContext()\noutput = ctx.out(\"optional_output\")\n\nmy_function(input_data, output)\n\nif ctx.is_set(\"optional_output\"):\n    # Output was written\n    process_output(ctx.outputs[\"optional_output\"])\nelse:\n    # Output was not written (conditional logic in function)\n    pass\n</code></pre>"},{"location":"api/context/#functiontestcontext-properties","title":"<code>FunctionTestContext</code> Properties","text":""},{"location":"api/context/#outputs-dictstr-any","title":"<code>outputs: dict[str, Any]</code>","text":"<p>Dictionary containing all captured output values.</p> <p>Type: <code>dict[str, Any]</code></p> <p><code>outputs</code> Example:</p> <pre><code>ctx = FunctionTestContext()\n\nmy_function(\n    input_data,\n    ctx.out(\"queue\"),\n    ctx.out(\"blob\")\n)\n\n# Access all outputs\nassert ctx.outputs[\"queue\"] == {\"message\": \"processed\"}\nassert ctx.outputs[\"blob\"] == b\"file content\"\n\n# Iterate outputs\nfor name, value in ctx.outputs.items():\n    print(f\"{name}: {value}\")\n</code></pre>"},{"location":"api/context/#capturedoutputt","title":"<code>CapturedOutput[T]</code>","text":"<p>A generic output capture that records values written by the function.</p>"},{"location":"api/context/#capturedoutputt-class-definition","title":"<code>CapturedOutput[T]</code> Class Definition","text":"<pre><code>@dataclass\nclass CapturedOutput(Out[T], Generic[T]):\n    \"\"\"Captures output binding values for testing.\"\"\"\n</code></pre>"},{"location":"api/context/#capturedoutputt-methods","title":"<code>CapturedOutput[T]</code> Methods","text":""},{"location":"api/context/#setval-t-none","title":"<code>set(val: T) -&gt; None</code>","text":"<p>Set the output value (called by the function under test).</p> <p><code>set()</code> Parameters:</p> <ul> <li><code>val</code> (<code>T</code>): The value to write to the output binding</li> </ul> <p><code>set()</code> Example:</p> <pre><code>def process_order(msg: QueueMessage, output: Out[str]) -&gt; None:\n    order = msg.get_json()\n    result = {\"order_id\": order[\"id\"], \"status\": \"processed\"}\n    output.set(json.dumps(result))\n\n# In test:\nctx = FunctionTestContext()\noutput = ctx.out(\"result\")\n\nprocess_order(msg, output)\n\n# Output was captured\nassert json.loads(ctx.outputs[\"result\"])[\"status\"] == \"processed\"\n</code></pre>"},{"location":"api/context/#get-t-none","title":"<code>get() -&gt; T | None</code>","text":"<p>Get the captured value.</p> <p><code>get()</code> Returns:</p> <ul> <li><code>T | None</code>: The captured value, or <code>None</code> if not set</li> </ul> <p><code>get()</code> Example:**</p> <pre><code>output = ctx.out(\"result\")\nmy_function(input_data, output)\n\nvalue = output.get()\nif value is not None:\n    # Output was set\n    process(value)\n</code></pre>"},{"location":"api/context/#usage-patterns","title":"Usage Patterns","text":""},{"location":"api/context/#single-output-binding","title":"Single Output Binding","text":"<pre><code>from azure_functions_test import FunctionTestContext, mock_queue_message\n\ndef test_process_message():\n    # Arrange\n    msg = mock_queue_message({\"order_id\": 123})\n    ctx = FunctionTestContext()\n\n    # Act\n    process_message(msg, ctx.out(\"result\"))\n\n    # Assert\n    assert ctx.outputs[\"result\"][\"order_id\"] == 123\n    assert ctx.outputs[\"result\"][\"status\"] == \"completed\"\n</code></pre>"},{"location":"api/context/#multiple-output-bindings","title":"Multiple Output Bindings","text":"<pre><code>def test_multi_output_function():\n    ctx = FunctionTestContext()\n\n    my_function(\n        input_data,\n        ctx.out(\"queue\"),\n        ctx.out(\"blob\"),\n        ctx.out(\"table\")\n    )\n\n    # All outputs captured\n    assert ctx.outputs[\"queue\"] is not None\n    assert ctx.outputs[\"blob\"] is not None\n    assert ctx.outputs[\"table\"] is not None\n</code></pre>"},{"location":"api/context/#conditional-outputs","title":"Conditional Outputs","text":"<pre><code>def test_conditional_output():\n    ctx = FunctionTestContext()\n\n    # Function only writes to error output on failure\n    process_with_validation(\n        invalid_input,\n        ctx.out(\"success\"),\n        ctx.out(\"error\")\n    )\n\n    # Check which output was set\n    assert not ctx.is_set(\"success\")\n    assert ctx.is_set(\"error\")\n    assert \"validation failed\" in ctx.outputs[\"error\"]\n</code></pre>"},{"location":"api/context/#type-safe-outputs","title":"Type-Safe Outputs","text":"<pre><code>from typing import TypedDict\n\nclass OrderOutput(TypedDict):\n    order_id: int\n    status: str\n    total: float\n\ndef test_typed_output():\n    ctx = FunctionTestContext()\n    output: CapturedOutput[OrderOutput] = ctx.out(\"order\")\n\n    process_order(input_msg, output)\n\n    # Type checker knows the structure\n    result = ctx.outputs[\"order\"]\n    assert result[\"order_id\"] == 123\n    assert result[\"status\"] == \"completed\"\n</code></pre>"},{"location":"api/context/#testing-error-handling","title":"Testing Error Handling","text":"<pre><code>def test_error_output():\n    ctx = FunctionTestContext()\n\n    try:\n        faulty_function(bad_input, ctx.out(\"result\"))\n    except ValueError:\n        pass  # Expected\n\n    # Verify no output was written before error\n    assert not ctx.is_set(\"result\")\n</code></pre>"},{"location":"api/context/#integration-with-azure-functions","title":"Integration with Azure Functions","text":"<p>The context API is designed to work seamlessly with Azure Functions signatures:</p>"},{"location":"api/context/#queue-trigger-example","title":"Queue Trigger Example","text":"<pre><code># Function code\nimport azure.functions as func\n\ndef main(msg: func.QueueMessage, result: func.Out[str]) -&gt; None:\n    data = msg.get_json()\n    processed = process_data(data)\n    result.set(json.dumps(processed))\n\n# Test code\ndef test_main():\n    from azure_functions_test import mock_queue_message, FunctionTestContext\n\n    msg = mock_queue_message({\"user\": \"alice\"})\n    ctx = FunctionTestContext()\n\n    main(msg, ctx.out(\"result\"))\n\n    output = json.loads(ctx.outputs[\"result\"])\n    assert output[\"user\"] == \"alice\"\n</code></pre>"},{"location":"api/context/#http-trigger-example","title":"HTTP Trigger Example","text":"<pre><code># Function code\ndef main(req: func.HttpRequest, msg: func.Out[str]) -&gt; func.HttpResponse:\n    name = req.params.get(\"name\")\n    msg.set(f\"Processed request from {name}\")\n    return func.HttpResponse(f\"Hello, {name}!\")\n\n# Test code\ndef test_main():\n    from azure_functions_test import mock_http_request, FunctionTestContext\n\n    req = mock_http_request(params={\"name\": \"Alice\"})\n    ctx = FunctionTestContext()\n\n    response = main(req, ctx.out(\"msg\"))\n\n    assert response.status_code == 200\n    assert ctx.outputs[\"msg\"] == \"Processed request from Alice\"\n</code></pre>"},{"location":"api/context/#best-practices","title":"Best Practices","text":""},{"location":"api/context/#1-use-descriptive-output-names","title":"1. Use Descriptive Output Names","text":"<pre><code># Good\nctx.out(\"processed_orders\")\nctx.out(\"error_log\")\nctx.out(\"notification_queue\")\n\n# Avoid\nctx.out(\"out1\")\nctx.out(\"output\")\nctx.out(\"result\")\n</code></pre>"},{"location":"api/context/#2-check-output-before-accessing","title":"2. Check Output Before Accessing","text":"<pre><code># Safe\nif ctx.is_set(\"optional_output\"):\n    value = ctx.outputs[\"optional_output\"]\n\n# Risky - may raise KeyError\nvalue = ctx.outputs[\"optional_output\"]\n</code></pre>"},{"location":"api/context/#3-type-annotations","title":"3. Type Annotations","text":"<pre><code># Type-safe\noutput: CapturedOutput[dict[str, Any]] = ctx.out(\"result\")\n\n# Less safe\noutput = ctx.out(\"result\")\n</code></pre>"},{"location":"api/context/#4-clear-test-arrangement","title":"4. Clear Test Arrangement","text":"<pre><code>def test_function():\n    # Arrange - setup inputs and context\n    msg = mock_queue_message(test_data)\n    ctx = FunctionTestContext()\n\n    # Act - call function\n    my_function(msg, ctx.out(\"result\"))\n\n    # Assert - verify outputs\n    assert ctx.outputs[\"result\"] == expected\n</code></pre>"},{"location":"api/context/#see-also","title":"See Also","text":"<ul> <li>Mock API Reference - For creating test inputs</li> <li>Examples - Real-world usage examples</li> </ul>"},{"location":"api/mocks/","title":"Mock API Reference","text":"<p>This page documents all available mock functions for Azure Functions triggers.</p>"},{"location":"api/mocks/#overview","title":"Overview","text":"<p>Each mock function creates a test double for an Azure Functions trigger input. All mocks:</p> <ul> <li>Return objects that implement the corresponding Azure SDK protocol</li> <li>Accept flexible input types with automatic serialization</li> <li>Provide sensible defaults for optional parameters</li> <li>Are fully type-safe with Pyright strict mode</li> </ul>"},{"location":"api/mocks/#available-mocks","title":"Available Mocks","text":"Mock Function Trigger Type Use Case <code>mock_queue_message()</code> Queue Storage Testing queue-triggered functions <code>mock_http_request()</code> HTTP Testing HTTP-triggered functions <code>mock_timer_request()</code> Timer Testing scheduled functions <code>mock_blob()</code> Blob Storage Testing blob-triggered functions <code>mock_service_bus_message()</code> Service Bus Testing service bus functions <code>mock_event_grid_event()</code> Event Grid Testing event grid functions"},{"location":"api/mocks/#mock_queue_message","title":"<code>mock_queue_message()</code>","text":"<p>Create a mock Queue Storage message.</p>"},{"location":"api/mocks/#mock_queue_message-signature","title":"<code>mock_queue_message()</code> Signature","text":"<pre><code>def mock_queue_message(\n    body: dict[Any, Any] | list[Any] | str | bytes | None = None,\n    *,\n    id: str | None = None,\n    dequeue_count: int | None = None,\n    expiration_time: datetime | None = None,\n    insertion_time: datetime | None = None,\n    time_next_visible: datetime | None = None,\n    pop_receipt: str | None = None,\n) -&gt; QueueMessageProtocol\n</code></pre>"},{"location":"api/mocks/#mock_queue_message-parameters","title":"<code>mock_queue_message()</code> Parameters","text":"Parameter Type Default Description <code>body</code> <code>dict \\| list \\| str \\| bytes \\| None</code> <code>None</code> Message body. Dicts/lists auto-serialize to JSON <code>id</code> <code>str \\| None</code> <code>\"test-message-id\"</code> Message ID assigned by Queue Storage <code>dequeue_count</code> <code>int \\| None</code> <code>1</code> Number of times the message has been dequeued <code>expiration_time</code> <code>datetime \\| None</code> <code>None</code> When the message expires <code>insertion_time</code> <code>datetime \\| None</code> Current UTC time When the message was inserted <code>time_next_visible</code> <code>datetime \\| None</code> <code>None</code> When the message will be visible next <code>pop_receipt</code> <code>str \\| None</code> <code>\"test-pop-receipt\"</code> Pop receipt token for operations"},{"location":"api/mocks/#mock_queue_message-returns","title":"<code>mock_queue_message()</code> Returns","text":"<p><code>QueueMessageProtocol</code> - A mock queue message implementing the Azure SDK interface.</p>"},{"location":"api/mocks/#mock_queue_message-examples","title":"<code>mock_queue_message()</code> Examples","text":"<p>Simple JSON message:</p> <pre><code>from azure_functions_test import mock_queue_message\n\nmsg = mock_queue_message({\"order_id\": 123, \"status\": \"pending\"})\nassert msg.get_json() == {\"order_id\": 123, \"status\": \"pending\"}\n</code></pre> <p>String message:</p> <pre><code>msg = mock_queue_message(\"Hello, World!\")\nassert msg.get_body() == b\"Hello, World!\"\n</code></pre> <p>Simulating poison message:</p> <pre><code>msg = mock_queue_message(\n    {\"failed_order\": 456},\n    dequeue_count=6  # Exceeds typical max retry count\n)\nif msg.dequeue_count &gt; 5:\n    # Move to dead letter queue\n    pass\n</code></pre>"},{"location":"api/mocks/#mock_http_request","title":"<code>mock_http_request()</code>","text":"<p>Create a mock HTTP request.</p>"},{"location":"api/mocks/#mock_http_request-signature","title":"<code>mock_http_request()</code> Signature","text":"<pre><code>def mock_http_request(\n    body: dict[Any, Any] | str | bytes | None = None,\n    *,\n    method: str = \"GET\",\n    url: str = \"http://localhost\",\n    headers: dict[str, str] | None = None,\n    params: dict[str, str] | None = None,\n    route_params: dict[str, str] | None = None,\n) -&gt; HttpRequestProtocol\n</code></pre>"},{"location":"api/mocks/#mock_http_request-parameters","title":"<code>mock_http_request()</code> Parameters","text":"Parameter Type Default Description <code>body</code> <code>dict \\| str \\| bytes \\| None</code> <code>None</code> Request body. Dicts auto-serialize to JSON <code>method</code> <code>str</code> <code>\"GET\"</code> HTTP method (GET, POST, PUT, DELETE, etc.) <code>url</code> <code>str</code> <code>\"http://localhost\"</code> Full request URL <code>headers</code> <code>dict[str, str] \\| None</code> <code>{}</code> HTTP headers <code>params</code> <code>dict[str, str] \\| None</code> <code>{}</code> Query parameters <code>route_params</code> <code>dict[str, str] \\| None</code> <code>{}</code> Route parameters (e.g., <code>/users/{id}</code>)"},{"location":"api/mocks/#mock_http_request-returns","title":"<code>mock_http_request()</code> Returns","text":"<p><code>HttpRequestProtocol</code> - A mock HTTP request implementing the Azure SDK interface.</p>"},{"location":"api/mocks/#mock_http_request-examples","title":"<code>mock_http_request()</code> Examples","text":"<p>Simple GET request:</p> <pre><code>from azure_functions_test import mock_http_request\n\nreq = mock_http_request(\n    method=\"GET\",\n    url=\"http://example.com/api/users\",\n    params={\"page\": \"1\", \"limit\": \"10\"}\n)\nassert req.method == \"GET\"\nassert req.params[\"page\"] == \"1\"\n</code></pre> <p>POST with JSON body:</p> <pre><code>req = mock_http_request(\n    body={\"name\": \"Alice\", \"email\": \"alice@example.com\"},\n    method=\"POST\",\n    url=\"http://example.com/api/users\"\n)\ndata = req.get_json()\nassert data[\"name\"] == \"Alice\"\n</code></pre> <p>Request with route parameters:</p> <pre><code>req = mock_http_request(\n    method=\"GET\",\n    route_params={\"user_id\": \"123\"}\n)\nuser_id = req.route_params[\"user_id\"]\n</code></pre> <p>Form data (application/x-www-form-urlencoded):</p> <pre><code>req = mock_http_request(\n    body=b\"name=Alice&amp;age=30&amp;email=alice%40example.com\",\n    method=\"POST\",\n    headers={\"Content-Type\": \"application/x-www-form-urlencoded\"}\n)\n# Form data is automatically parsed\nassert req.form[\"name\"] == \"Alice\"\nassert req.form[\"age\"] == \"30\"\nassert req.form[\"email\"] == \"alice@example.com\"\n</code></pre> <p>Note: The <code>form</code> property automatically parses URL-encoded form data when the Content-Type is <code>application/x-www-form-urlencoded</code>. Form data is cached for performance.</p>"},{"location":"api/mocks/#mock_timer_request","title":"<code>mock_timer_request()</code>","text":"<p>Create a mock timer request.</p>"},{"location":"api/mocks/#mock_timer_request-signature","title":"<code>mock_timer_request()</code> Signature","text":"<pre><code>def mock_timer_request(\n    *,\n    past_due: bool = False,\n    schedule_status: dict[str, Any] | None = None,\n    schedule: dict[str, Any] | None = None,\n) -&gt; TimerRequestProtocol\n</code></pre>"},{"location":"api/mocks/#mock_timer_request-parameters","title":"<code>mock_timer_request()</code> Parameters","text":"Parameter Type Default Description <code>past_due</code> <code>bool</code> <code>False</code> Whether the timer is past its scheduled time <code>schedule_status</code> <code>dict[str, Any] \\| None</code> Current time info Schedule status with Last/Next/LastUpdated times <code>schedule</code> <code>dict[str, Any] \\| None</code> <code>{}</code> Timer schedule configuration (e.g., cron expression)"},{"location":"api/mocks/#mock_timer_request-returns","title":"<code>mock_timer_request()</code> Returns","text":"<p><code>TimerRequestProtocol</code> - A mock timer request implementing the Azure SDK interface.</p>"},{"location":"api/mocks/#mock_timer_request-examples","title":"<code>mock_timer_request()</code> Examples","text":"<p>Normal timer execution:</p> <pre><code>from azure_functions_test import mock_timer_request\n\ntimer = mock_timer_request()\nassert timer.past_due == False\n</code></pre> <p>Past due timer:</p> <pre><code>timer = mock_timer_request(past_due=True)\nif timer.past_due:\n    # Handle backlog or skip execution\n    pass\n</code></pre> <p>Timer with schedule information:</p> <pre><code>from datetime import datetime, UTC, timedelta\n\nnow = datetime.now(UTC)\ntimer = mock_timer_request(\n    schedule_status={\n        \"Last\": now - timedelta(hours=1),\n        \"Next\": now + timedelta(hours=1),\n        \"LastUpdated\": now\n    },\n    schedule={\"AdjustForDST\": True, \"Expression\": \"0 0 */6 * * *\"}\n)\nassert timer.schedule_status[\"Last\"] &lt; timer.schedule_status[\"Next\"]\nassert timer.schedule[\"Expression\"] == \"0 0 */6 * * *\"\n</code></pre> <p>Note: The <code>schedule_status</code> property contains Last/Next/LastUpdated datetimes. The <code>schedule</code> property holds timer configuration like cron expressions.</p>"},{"location":"api/mocks/#mock_blob","title":"<code>mock_blob()</code>","text":"<p>Create a mock Blob Storage input stream.</p>"},{"location":"api/mocks/#mock_blob-signature","title":"<code>mock_blob()</code> Signature","text":"<pre><code>def mock_blob(\n    content: str | bytes | None = None,\n    *,\n    name: str | None = None,\n    uri: str | None = None,\n) -&gt; InputStreamProtocol\n</code></pre>"},{"location":"api/mocks/#mock_blob-parameters","title":"<code>mock_blob()</code> Parameters","text":"Parameter Type Default Description <code>content</code> <code>str \\| bytes \\| None</code> <code>None</code> Blob content. Strings are UTF-8 encoded <code>name</code> <code>str \\| None</code> <code>\"test-blob.txt\"</code> Blob name <code>uri</code> <code>str \\| None</code> Test URI Blob's primary location URI"},{"location":"api/mocks/#mock_blob-returns","title":"<code>mock_blob()</code> Returns","text":"<p><code>InputStreamProtocol</code> - A mock blob input stream implementing the Azure SDK interface.</p>"},{"location":"api/mocks/#mock_blob-examples","title":"<code>mock_blob()</code> Examples","text":"<p>Text file blob:</p> <pre><code>from azure_functions_test import mock_blob\n\nblob = mock_blob(\n    content=\"Hello, World!\",\n    name=\"greeting.txt\"\n)\nassert blob.read() == b\"Hello, World!\"\nassert blob.length == 13\n</code></pre> <p>Binary blob:</p> <pre><code>blob = mock_blob(\n    content=b\"\\x89PNG\\r\\n\\x1a\\n\",\n    name=\"image.png\"\n)\ndata = blob.read()\n</code></pre> <p>Reading in chunks:</p> <pre><code>blob = mock_blob(\"Hello, World!\")\nchunk1 = blob.read(5)  # b\"Hello\"\nchunk2 = blob.read(7)  # b\", World\"\n</code></pre>"},{"location":"api/mocks/#mock_service_bus_message","title":"<code>mock_service_bus_message()</code>","text":"<p>Create a mock Service Bus message.</p>"},{"location":"api/mocks/#mock_service_bus_message-signature","title":"<code>mock_service_bus_message()</code> Signature","text":"<pre><code>def mock_service_bus_message(\n    body: dict[Any, Any] | str | bytes | None = None,\n    *,\n    message_id: str | None = None,\n    session_id: str | None = None,\n    partition_key: str | None = None,\n    content_type: str | None = None,\n    correlation_id: str | None = None,\n    delivery_count: int | None = None,\n    enqueued_time_utc: datetime | None = None,\n    expires_at_utc: datetime | None = None,\n    dead_letter_source: str | None = None,\n    dead_letter_reason: str | None = None,\n    dead_letter_error_description: str | None = None,\n    application_properties: dict[str, Any] | None = None,\n    user_properties: dict[str, Any] | None = None,\n) -&gt; ServiceBusMessageProtocol\n</code></pre>"},{"location":"api/mocks/#mock_service_bus_message-parameters","title":"<code>mock_service_bus_message()</code> Parameters","text":"Parameter Type Default Description <code>body</code> <code>dict \\| str \\| bytes \\| None</code> <code>None</code> Message body <code>message_id</code> <code>str \\| None</code> <code>\"test-message-id\"</code> Unique message identifier <code>session_id</code> <code>str \\| None</code> <code>None</code> Session identifier for stateful processing <code>partition_key</code> <code>str \\| None</code> <code>None</code> Partition key for ordering <code>content_type</code> <code>str \\| None</code> <code>\"application/json\"</code> MIME type of the message <code>correlation_id</code> <code>str \\| None</code> <code>None</code> Correlation identifier <code>delivery_count</code> <code>int \\| None</code> <code>1</code> Number of delivery attempts <code>enqueued_time_utc</code> <code>datetime \\| None</code> Current UTC When message was enqueued <code>expires_at_utc</code> <code>datetime \\| None</code> <code>None</code> Message expiration time <code>dead_letter_source</code> <code>str \\| None</code> <code>None</code> Original queue if dead-lettered <code>dead_letter_reason</code> <code>str \\| None</code> <code>None</code> Reason for dead-lettering <code>dead_letter_error_description</code> <code>str \\| None</code> <code>None</code> Error description <code>application_properties</code> <code>dict[str, Any] \\| None</code> <code>{}</code> Application-specific properties <code>user_properties</code> <code>dict[str, Any] \\| None</code> <code>{}</code> User-defined properties"},{"location":"api/mocks/#mock_service_bus_message-returns","title":"<code>mock_service_bus_message()</code> Returns","text":"<p><code>ServiceBusMessageProtocol</code> - A mock Service Bus message implementing the Azure SDK interface.</p>"},{"location":"api/mocks/#mock_service_bus_message-examples","title":"<code>mock_service_bus_message()</code> Examples","text":"<p>Basic message:</p> <pre><code>from azure_functions_test import mock_service_bus_message\n\nmsg = mock_service_bus_message(\n    {\"event\": \"order.created\", \"order_id\": 123}\n)\nassert msg.get_json()[\"event\"] == \"order.created\"\n</code></pre> <p>Session-enabled message:</p> <pre><code>msg = mock_service_bus_message(\n    {\"user_id\": \"alice\", \"action\": \"login\"},\n    session_id=\"user-alice\"\n)\n</code></pre> <p>Dead letter message:</p> <pre><code>msg = mock_service_bus_message(\n    {\"failed_data\": \"...\"},\n    dead_letter_source=\"orders-queue\",\n    dead_letter_reason=\"ProcessingError\",\n    dead_letter_error_description=\"Invalid order format\"\n)\n</code></pre>"},{"location":"api/mocks/#mock_event_grid_event","title":"<code>mock_event_grid_event()</code>","text":"<p>Create a mock Event Grid event.</p>"},{"location":"api/mocks/#mock_event_grid_event-signature","title":"<code>mock_event_grid_event()</code> Signature","text":"<pre><code>def mock_event_grid_event(\n    *,\n    data: dict[str, Any] | None = None,\n    id: str | None = None,\n    topic: str | None = None,\n    subject: str | None = None,\n    event_type: str | None = None,\n    event_time: datetime | None = None,\n    data_version: str | None = None,\n) -&gt; EventGridEventProtocol\n</code></pre>"},{"location":"api/mocks/#mock_event_grid_event-parameters","title":"<code>mock_event_grid_event()</code> Parameters","text":"Parameter Type Default Description <code>data</code> <code>dict[str, Any] \\| None</code> <code>{}</code> Event data payload <code>id</code> <code>str \\| None</code> <code>\"test-event-id\"</code> Unique event identifier <code>topic</code> <code>str \\| None</code> <code>\"/test/topic\"</code> Event source topic <code>subject</code> <code>str \\| None</code> <code>\"/test/subject\"</code> Subject/path within topic <code>event_type</code> <code>str \\| None</code> <code>\"Test.Event\"</code> Event type identifier <code>event_time</code> <code>datetime \\| None</code> Current UTC When the event occurred <code>data_version</code> <code>str \\| None</code> <code>\"1.0\"</code> Schema version of event data"},{"location":"api/mocks/#mock_event_grid_event-returns","title":"<code>mock_event_grid_event()</code> Returns","text":"<p><code>EventGridEventProtocol</code> - A mock Event Grid event implementing the Azure SDK interface.</p>"},{"location":"api/mocks/#mock_event_grid_event-examples","title":"<code>mock_event_grid_event()</code> Examples","text":"<p>Blob created event:</p> <pre><code>from azure_functions_test import mock_event_grid_event\n\nevent = mock_event_grid_event(\n    data={\n        \"url\": \"https://myaccount.blob.core.windows.net/container/file.txt\",\n        \"contentType\": \"text/plain\"\n    },\n    event_type=\"Microsoft.Storage.BlobCreated\",\n    subject=\"/blobServices/default/containers/mycontainer/blobs/file.txt\"\n)\n</code></pre> <p>Custom event:</p> <pre><code>event = mock_event_grid_event(\n    data={\"order_id\": 123, \"total\": 99.99},\n    event_type=\"MyApp.Order.Created\",\n    subject=\"/orders/123\",\n    topic=\"/subscriptions/xyz/resourceGroups/myapp/providers/MyApp/orders\"\n)\n</code></pre>"},{"location":"api/mocks/#event-grid-factory-functions","title":"Event Grid Factory Functions","text":"<p>For common Event Grid scenarios, convenience factory functions are available:</p>"},{"location":"api/mocks/#create_blob_created_event","title":"<code>create_blob_created_event()</code>","text":"<p>Create a Blob Storage 'BlobCreated' event with realistic Azure metadata.</p> <pre><code>from azure_functions_test.mocks.eventgrid import create_blob_created_event\n\nevent = create_blob_created_event(\n    \"https://myaccount.blob.core.windows.net/container/file.txt\",\n    container_name=\"uploads\",\n    storage_account=\"myaccount\"\n)\nassert event.event_type == \"Microsoft.Storage.BlobCreated\"\nassert event.get_json()[\"url\"] == \"https://myaccount.blob.core.windows.net/container/file.txt\"\n</code></pre> <p>Parameters: - <code>blob_url</code> (str): URL of the created blob - <code>container_name</code> (str): Container name (default: \"test-container\") - <code>blob_name</code> (str | None): Blob name (extracted from URL if not provided) - <code>storage_account</code> (str): Storage account name (default: \"teststorageaccount\")</p>"},{"location":"api/mocks/#create_blob_deleted_event","title":"<code>create_blob_deleted_event()</code>","text":"<p>Create a Blob Storage 'BlobDeleted' event.</p> <pre><code>from azure_functions_test.mocks.eventgrid import create_blob_deleted_event\n\nevent = create_blob_deleted_event(\n    \"https://myaccount.blob.core.windows.net/archive/old-file.txt\"\n)\nassert event.event_type == \"Microsoft.Storage.BlobDeleted\"\n</code></pre> <p>Parameters: Same as <code>create_blob_created_event()</code></p>"},{"location":"api/mocks/#create_custom_event","title":"<code>create_custom_event()</code>","text":"<p>Create a custom application Event Grid event.</p> <pre><code>from azure_functions_test.mocks.eventgrid import create_custom_event\n\nevent = create_custom_event(\n    data={\"userId\": 123, \"action\": \"login\"},\n    event_type=\"MyApp.User.Login\",\n    subject=\"users/123/login\"\n)\nassert event.event_type == \"MyApp.User.Login\"\nassert event.get_json()[\"userId\"] == 123\n</code></pre> <p>Parameters: - <code>data</code> (dict[str, Any]): Custom event data - <code>event_type</code> (str): Custom event type (default: \"Custom.Application.Event\") - <code>subject</code> (str): Event subject path (default: \"custom/event\")</p>"},{"location":"api/mocks/#see-also","title":"See Also","text":"<ul> <li>Context API - For capturing function outputs</li> <li>Protocols - Protocol definitions for type safety</li> <li>Examples - Real-world usage examples</li> </ul>"},{"location":"api/protocols/","title":"Protocols Reference","text":"<p>Protocol types for structural typing in <code>azure-functions-test</code>.</p>"},{"location":"api/protocols/#overview","title":"Overview","text":"<p>Protocols define the interfaces that Azure Functions expects for trigger inputs. Our mocks implement these protocols using structural typing (duck typing), allowing them to be drop-in replacements for Azure SDK types without inheritance.</p>"},{"location":"api/protocols/#why-protocols","title":"Why Protocols?","text":"<pre><code># With protocols, this works:\nfrom azure_functions_test import mock_queue_message\nfrom azure_functions_test.protocols import QueueMessageProtocol\n\ndef process_message(msg: QueueMessageProtocol) -&gt; None:\n    data = msg.get_json()  # \u2713 Type checker knows this exists\n    id = msg.id            # \u2713 Type checker knows this property\n\n# Mock is structurally compatible:\nmsg = mock_queue_message({\"test\": \"data\"})\nprocess_message(msg)  # \u2713 Works! No inheritance needed\n</code></pre>"},{"location":"api/protocols/#available-protocols","title":"Available Protocols","text":"Protocol Azure SDK Type Mock Function <code>QueueMessageProtocol</code> <code>azure.functions.QueueMessage</code> <code>mock_queue_message()</code> <code>HttpRequestProtocol</code> <code>azure.functions.HttpRequest</code> <code>mock_http_request()</code> <code>TimerRequestProtocol</code> <code>azure.functions.TimerRequest</code> <code>mock_timer_request()</code> <code>InputStreamProtocol</code> <code>azure.functions.InputStream</code> <code>mock_blob()</code> <code>ServiceBusMessageProtocol</code> <code>azure.functions.ServiceBusMessage</code> <code>mock_service_bus_message()</code> <code>EventGridEventProtocol</code> <code>azure.functions.EventGridEvent</code> <code>mock_event_grid_event()</code>"},{"location":"api/protocols/#queuemessageprotocol","title":"<code>QueueMessageProtocol</code>","text":"<p>Structural type for Azure Queue Storage trigger messages.</p>"},{"location":"api/protocols/#properties","title":"Properties","text":"<pre><code>@property\ndef id(self) -&gt; str | None: ...\n\n@property\ndef dequeue_count(self) -&gt; int | None: ...\n\n@property\ndef expiration_time(self) -&gt; datetime | None: ...\n\n@property\ndef insertion_time(self) -&gt; datetime | None: ...\n\n@property\ndef time_next_visible(self) -&gt; datetime | None: ...\n\n@property\ndef pop_receipt(self) -&gt; str | None: ...\n</code></pre>"},{"location":"api/protocols/#methods","title":"Methods","text":"<pre><code>def get_body(self) -&gt; bytes: ...\ndef get_json(self) -&gt; Any: ...\n</code></pre>"},{"location":"api/protocols/#example","title":"Example","text":"<pre><code>from azure_functions_test.protocols import QueueMessageProtocol\n\ndef process_order(msg: QueueMessageProtocol) -&gt; dict:\n    \"\"\"Process an order from queue message.\"\"\"\n    order = msg.get_json()\n    print(f\"Processing message {msg.id}, attempt {msg.dequeue_count}\")\n    return {\"status\": \"processed\", \"order_id\": order[\"id\"]}\n</code></pre>"},{"location":"api/protocols/#httprequestprotocol","title":"<code>HttpRequestProtocol</code>","text":"<p>Structural type for Azure HTTP trigger requests.</p>"},{"location":"api/protocols/#properties_1","title":"Properties","text":"<pre><code>@property\ndef method(self) -&gt; str: ...\n\n@property\ndef url(self) -&gt; str: ...\n\n@property\ndef headers(self) -&gt; Mapping[str, str]: ...\n\n@property\ndef params(self) -&gt; Mapping[str, str]: ...\n\n@property\ndef route_params(self) -&gt; Mapping[str, str]: ...\n\n@property\ndef form(self) -&gt; dict[str, str]: ...\n</code></pre>"},{"location":"api/protocols/#methods_1","title":"Methods","text":"<pre><code>def get_body(self) -&gt; bytes: ...\ndef get_json(self) -&gt; Any: ...\n</code></pre>"},{"location":"api/protocols/#example_1","title":"Example","text":"<pre><code>from azure_functions_test.protocols import HttpRequestProtocol\nfrom azure.functions import HttpResponse\n\ndef handle_request(req: HttpRequestProtocol) -&gt; HttpResponse:\n    \"\"\"Handle HTTP request with type safety.\"\"\"\n    if req.method == \"POST\":\n        data = req.get_json()\n        return HttpResponse(f\"Created: {data}\", status_code=201)\n    elif req.method == \"GET\":\n        user_id = req.route_params.get(\"id\")\n        return HttpResponse(f\"User: {user_id}\")\n    else:\n        return HttpResponse(\"Method not allowed\", status_code=405)\n</code></pre>"},{"location":"api/protocols/#timerrequestprotocol","title":"<code>TimerRequestProtocol</code>","text":"<p>Structural type for Azure Timer trigger requests.</p>"},{"location":"api/protocols/#properties_2","title":"Properties","text":"<pre><code>@property\ndef past_due(self) -&gt; bool: ...\n\n@property\ndef schedule_status(self) -&gt; dict[str, Any]: ...\n\n@property\ndef schedule(self) -&gt; dict[str, Any]: ...\n</code></pre>"},{"location":"api/protocols/#example_2","title":"Example","text":"<pre><code>from azure_functions_test.protocols import TimerRequestProtocol\n\ndef scheduled_cleanup(timer: TimerRequestProtocol) -&gt; None:\n    \"\"\"Run scheduled cleanup task.\"\"\"\n    if timer.past_due:\n        print(\"Timer is past due, catching up...\")\n\n    # Perform cleanup\n    cleanup_old_records()\n</code></pre>"},{"location":"api/protocols/#inputstreamprotocol","title":"<code>InputStreamProtocol</code>","text":"<p>Structural type for Azure Blob Storage input streams.</p>"},{"location":"api/protocols/#properties_3","title":"Properties","text":"<pre><code>@property\ndef name(self) -&gt; str | None: ...\n\n@property\ndef length(self) -&gt; int | None: ...\n\n@property\ndef uri(self) -&gt; str | None: ...\n</code></pre>"},{"location":"api/protocols/#methods_2","title":"Methods","text":"<pre><code>def read(self, size: int = -1) -&gt; bytes: ...\n</code></pre>"},{"location":"api/protocols/#example_3","title":"Example","text":"<pre><code>from azure_functions_test.protocols import InputStreamProtocol\n\ndef process_blob(blob: InputStreamProtocol) -&gt; None:\n    \"\"\"Process blob file with type safety.\"\"\"\n    print(f\"Processing {blob.name} ({blob.length} bytes)\")\n\n    # Read in chunks\n    chunk_size = 4096\n    while True:\n        chunk = blob.read(chunk_size)\n        if not chunk:\n            break\n        process_chunk(chunk)\n</code></pre>"},{"location":"api/protocols/#servicebusmessageprotocol","title":"<code>ServiceBusMessageProtocol</code>","text":"<p>Structural type for Azure Service Bus messages.</p>"},{"location":"api/protocols/#properties_4","title":"Properties","text":"<pre><code>@property\ndef message_id(self) -&gt; str | None: ...\n\n@property\ndef session_id(self) -&gt; str | None: ...\n\n@property\ndef partition_key(self) -&gt; str | None: ...\n\n@property\ndef content_type(self) -&gt; str | None: ...\n\n@property\ndef correlation_id(self) -&gt; str | None: ...\n\n@property\ndef delivery_count(self) -&gt; int | None: ...\n\n@property\ndef enqueued_time_utc(self) -&gt; datetime | None: ...\n\n@property\ndef expires_at_utc(self) -&gt; datetime | None: ...\n\n@property\ndef dead_letter_source(self) -&gt; str | None: ...\n\n@property\ndef dead_letter_reason(self) -&gt; str | None: ...\n\n@property\ndef dead_letter_error_description(self) -&gt; str | None: ...\n\n@property\ndef application_properties(self) -&gt; dict[str, Any] | None: ...\n\n@property\ndef user_properties(self) -&gt; dict[str, Any] | None: ...\n</code></pre>"},{"location":"api/protocols/#methods_3","title":"Methods","text":"<pre><code>def get_body(self) -&gt; bytes: ...\ndef get_json(self) -&gt; Any: ...\n</code></pre>"},{"location":"api/protocols/#example_4","title":"Example","text":"<pre><code>from azure_functions_test.protocols import ServiceBusMessageProtocol\n\ndef handle_service_bus_message(msg: ServiceBusMessageProtocol) -&gt; None:\n    \"\"\"Handle Service Bus message with session support.\"\"\"\n    data = msg.get_json()\n\n    # Check if message is part of a session\n    if msg.session_id:\n        print(f\"Processing session message: {msg.session_id}\")\n\n    # Check delivery count for retry logic\n    if msg.delivery_count and msg.delivery_count &gt; 3:\n        print(f\"Message has been retried {msg.delivery_count} times\")\n\n    # Process the message\n    process_event(data)\n</code></pre>"},{"location":"api/protocols/#eventgrideventprotocol","title":"<code>EventGridEventProtocol</code>","text":"<p>Structural type for Azure Event Grid events.</p>"},{"location":"api/protocols/#properties_5","title":"Properties","text":"<pre><code>@property\ndef id(self) -&gt; str | None: ...\n\n@property\ndef topic(self) -&gt; str | None: ...\n\n@property\ndef subject(self) -&gt; str | None: ...\n\n@property\ndef event_type(self) -&gt; str | None: ...\n\n@property\ndef event_time(self) -&gt; datetime | None: ...\n\n@property\ndef data_version(self) -&gt; str | None: ...\n</code></pre>"},{"location":"api/protocols/#methods_4","title":"Methods","text":"<pre><code>def get_json(self) -&gt; dict[str, Any]: ...\n</code></pre>"},{"location":"api/protocols/#example_5","title":"Example","text":"<pre><code>from azure_functions_test.protocols import EventGridEventProtocol\n\ndef handle_event_grid_event(event: EventGridEventProtocol) -&gt; None:\n    \"\"\"Handle Event Grid event with type safety.\"\"\"\n    print(f\"Event type: {event.event_type}\")\n    print(f\"Subject: {event.subject}\")\n\n    data = event.get_json()\n\n    # Route based on event type\n    if event.event_type == \"Microsoft.Storage.BlobCreated\":\n        handle_blob_created(data)\n    elif event.event_type == \"MyApp.Order.Created\":\n        handle_order_created(data)\n</code></pre>"},{"location":"api/protocols/#type-safety-benefits","title":"Type Safety Benefits","text":""},{"location":"api/protocols/#autocomplete","title":"Autocomplete","text":"<pre><code>from azure_functions_test import mock_queue_message\n\nmsg = mock_queue_message({\"test\": \"data\"})\n\n# IDE shows available properties and methods:\nmsg.id  # \u2713 Property exists\nmsg.get_json()  # \u2713 Method exists\nmsg.invalid_prop  # \u2717 Type error\n</code></pre>"},{"location":"api/protocols/#compile-time-checks","title":"Compile-Time Checks","text":"<pre><code>from azure_functions_test.protocols import QueueMessageProtocol\n\ndef process(msg: QueueMessageProtocol) -&gt; None:\n    # Type checker validates:\n    data = msg.get_json()  # \u2713 Returns Any\n    count = msg.dequeue_count  # \u2713 Returns int | None\n\n    # Type errors caught:\n    msg.nonexistent()  # \u2717 Error: method doesn't exist\n</code></pre>"},{"location":"api/protocols/#interchangeability","title":"Interchangeability","text":"<pre><code>from azure_functions_test import mock_queue_message\nfrom azure_functions_test.protocols import QueueMessageProtocol\n\n# Function accepts protocol\ndef process(msg: QueueMessageProtocol) -&gt; None:\n    print(msg.get_json())\n\n# Works with mock\nmock_msg = mock_queue_message({\"test\": \"data\"})\nprocess(mock_msg)  # \u2713\n\n# Also works with real Azure SDK type\nfrom azure.functions import QueueMessage\nreal_msg: QueueMessage = ...\nprocess(real_msg)  # \u2713 Structural typing!\n</code></pre>"},{"location":"api/protocols/#advanced-usage","title":"Advanced Usage","text":""},{"location":"api/protocols/#generic-type-constraints","title":"Generic Type Constraints","text":"<pre><code>from typing import TypeVar\nfrom azure_functions_test.protocols import QueueMessageProtocol\n\nT = TypeVar(\"T\", bound=QueueMessageProtocol)\n\ndef batch_process(messages: list[T]) -&gt; list[dict]:\n    \"\"\"Process multiple messages with type safety.\"\"\"\n    return [msg.get_json() for msg in messages]\n\n# Works with any QueueMessageProtocol implementation\nmocks = [mock_queue_message({\"id\": i}) for i in range(10)]\nresults = batch_process(mocks)  # \u2713\n</code></pre>"},{"location":"api/protocols/#protocol-composition","title":"Protocol Composition","text":"<pre><code>from typing import Protocol\nfrom azure_functions_test.protocols import QueueMessageProtocol\n\nclass ProcessableMessage(Protocol):\n    \"\"\"Extended protocol for messages that can be processed.\"\"\"\n    def get_json(self) -&gt; dict: ...\n    @property\n    def id(self) -&gt; str | None: ...\n\ndef process(msg: ProcessableMessage) -&gt; None:\n    \"\"\"Process any message with get_json and id.\"\"\"\n    data = msg.get_json()\n    print(f\"Processing {msg.id}: {data}\")\n\n# QueueMessageProtocol is compatible (structural subtype)\nmsg = mock_queue_message({\"data\": \"test\"})\nprocess(msg)  # \u2713\n</code></pre>"},{"location":"api/protocols/#implementation-notes","title":"Implementation Notes","text":""},{"location":"api/protocols/#duck-typing","title":"Duck Typing","text":"<p>Protocols use structural subtyping (duck typing), not nominal subtyping:</p> <pre><code># This works WITHOUT inheritance:\nclass MyMock:\n    def get_json(self) -&gt; Any:\n        return {\"custom\": \"data\"}\n\n    def get_body(self) -&gt; bytes:\n        return b\"data\"\n\n    # ... implement all protocol properties/methods\n\n# MyMock implements QueueMessageProtocol without inheriting!\ndef process(msg: QueueMessageProtocol) -&gt; None:\n    print(msg.get_json())\n\nprocess(MyMock())  # \u2713 Works!\n</code></pre>"},{"location":"api/protocols/#runtime-type-checking","title":"Runtime Type Checking","text":"<p>Protocols are checked at static analysis time (Pyright, mypy), not runtime:</p> <pre><code>from azure_functions_test.protocols import QueueMessageProtocol\n\nmsg = mock_queue_message({\"data\": \"test\"})\n\n# Static check - always True\nisinstance(msg, QueueMessageProtocol)  # \u2717 Doesn't work at runtime\n\n# Use static typing instead\ndef process(msg: QueueMessageProtocol) -&gt; None:  # \u2713 Checked by Pyright\n    ...\n</code></pre>"},{"location":"api/protocols/#see-also","title":"See Also","text":"<ul> <li>Mock API Reference - Functions that return protocol implementations</li> <li>Context API - For capturing function outputs</li> <li>PEP 544 - Structural subtyping specification</li> </ul>"},{"location":"development/style-guide/","title":"Project Style Guide","text":"<p>This document outlines the coding style and conventions for the azure-functions-test project. All contributors and tools (including GitHub Copilot) must adhere to these standards.</p>"},{"location":"development/style-guide/#general-coding-standards","title":"General Coding Standards","text":""},{"location":"development/style-guide/#pep-8-compliance","title":"PEP 8 Compliance","text":"<p>We use Ruff to enforce PEP compliance throughout the codebase and expect all code to adhere to the following standards:</p> <ul> <li>Follow PEP 8 guidelines for Python code.</li> </ul>"},{"location":"development/style-guide/#line-width","title":"Line Width","text":"<ul> <li>Maximum line width: 88 characters.</li> <li>Use consistent line breaks to maintain readability.</li> </ul>"},{"location":"development/style-guide/#indentation","title":"Indentation","text":"<ul> <li>Use 4 spaces per indentation level.</li> <li>Do not use tabs.</li> </ul>"},{"location":"development/style-guide/#spelling-convention","title":"Spelling Convention","text":"<ul> <li>Use American English spellings throughout the codebase (to match Azure Functions SDK conventions).</li> <li>Examples of preferred spellings:</li> <li><code>behavior</code> not <code>behaviour</code></li> <li><code>initialize</code> not <code>initialise</code></li> <li><code>synchronize</code> not <code>synchronise</code></li> <li><code>serialize</code> not <code>serialise</code></li> <li>Exception: When referencing Azure Functions SDK classes/methods, use their exact spelling (e.g., <code>QueueMessage</code>, <code>HttpRequest</code>)</li> </ul>"},{"location":"development/style-guide/#docstring-style","title":"Docstring Style","text":""},{"location":"development/style-guide/#general-docstring-guidelines","title":"General Docstring Guidelines","text":"<ul> <li>All public functions, classes, and modules must have docstrings.</li> <li>Use Google-style docstrings for documentation.</li> <li>Private functions (prefixed with <code>_</code>) should have docstrings if their logic is non-trivial.</li> </ul>"},{"location":"development/style-guide/#google-style-docstring-example","title":"Google-Style Docstring Example","text":"<pre><code>def mock_queue_message(\n    body: dict | list | str | bytes | None = None,\n    *,\n    id: str | None = None,\n    dequeue_count: int | None = None,\n) -&gt; QueueMessageMock:\n    \"\"\"Create a mock QueueMessage for testing.\n\n    Args:\n        body: Message body. Dicts/lists are JSON-serialized automatically.\n        id: Message ID. Defaults to \"test-message-id\".\n        dequeue_count: Number of times dequeued. Defaults to 1.\n\n    Returns:\n        A mock that behaves like azure.functions.QueueMessage.\n\n    Example:\n        &gt;&gt;&gt; msg = mock_queue_message({\"order_id\": 123})\n        &gt;&gt;&gt; msg.get_json()\n        {'order_id': 123}\n    \"\"\"\n    pass\n</code></pre> <p>Key Points: - There's no need to include type hints again in the docstring, as they are already present in the function signature. - The function signature is authoritative for types. - Include examples for public API functions to show typical usage.</p>"},{"location":"development/style-guide/#type-hints","title":"Type Hints","text":""},{"location":"development/style-guide/#use-primitive-types-where-available","title":"Use Primitive Types Where Available","text":"<ul> <li>Use primitive types (<code>list</code>, <code>dict</code>, <code>tuple</code>, <code>set</code>) instead of their <code>typing</code> module equivalents.</li> <li>Prefer <code>list[str]</code> over <code>List[str]</code> (Python 3.9+)</li> <li>Prefer <code>dict[str, int]</code> over <code>Dict[str, int]</code> (Python 3.9+)</li> <li>Prefer <code>tuple[str, int]</code> over <code>Tuple[str, int]</code> (Python 3.9+)</li> <li>Use <code>T | None</code> instead of <code>Optional[T]</code> (Python 3.10+)</li> <li>Use <code>str | int</code> instead of <code>Union[str, int]</code> (Python 3.10+)</li> </ul> <p>Good:</p> <pre><code>def process_messages(items: list[str]) -&gt; dict[str, int]:\n    \"\"\"Process list of items and return counts.\"\"\"\n    return {item: len(item) for item in items}\n\ndef get_config(name: str) -&gt; dict[str, str] | None:\n    \"\"\"Get config by name, returns None if not found.\"\"\"\n    return None\n</code></pre> <p>Avoid:</p> <pre><code>from typing import Dict, List, Optional\n\ndef process_messages(items: List[str]) -&gt; Dict[str, int]:\n    \"\"\"Process list of items and return counts.\"\"\"\n    return {item: len(item) for item in items}\n\ndef get_config(name: str) -&gt; Optional[Dict[str, str]]:\n    \"\"\"Get config by name, returns None if not found.\"\"\"\n    return None\n</code></pre>"},{"location":"development/style-guide/#exception-use-typing-for-complex-types","title":"Exception: Use <code>typing</code> for Complex Types","text":"<p>Continue using <code>typing</code> module for complex type constructs:</p> <ul> <li><code>typing.Any</code> (no primitive equivalent)</li> <li><code>typing.TypeVar</code> (for generics)</li> <li><code>typing.Generic</code> (for generic classes)</li> <li><code>typing.Protocol</code> (for structural subtyping)</li> <li><code>typing.Callable[[str], bool]</code> (function types)</li> </ul>"},{"location":"development/style-guide/#minimum-python-version-39","title":"Minimum Python Version: 3.9","text":"<p>Since we target Python 3.9+: - Use <code>list[T]</code>, <code>dict[K, V]</code>, <code>tuple[T, ...]</code>, <code>set[T]</code> - For Python 3.10+ features (<code>|</code> union syntax), use <code>from __future__ import annotations</code> at the top of the file</p>"},{"location":"development/style-guide/#type-safety-and-data-structures","title":"Type Safety and Data Structures","text":""},{"location":"development/style-guide/#use-dataclasses-or-pydantic-for-structured-data","title":"Use Dataclasses or Pydantic for Structured Data","text":"<p>Rule: Always use typed dataclasses instead of raw dictionaries for application data.</p> <p>Working with raw dictionaries (<code>dict[str, Any]</code>) in application logic is not type-safe and should be avoided. Use strongly-typed dataclasses to ensure:</p> <ul> <li>Type checking catches errors at development time</li> <li>IDE autocomplete and refactoring support</li> <li>Clear contracts between components</li> <li>Self-documenting code</li> </ul> <p>Good:</p> <pre><code>from dataclasses import dataclass\n\n@dataclass\nclass MockConfig:\n    \"\"\"Configuration for mock object behaviour.\"\"\"\n    id: str\n    dequeue_count: int\n    auto_serialize: bool = True\n\ndef create_mock(config: MockConfig) -&gt; QueueMessageMock:\n    \"\"\"Create mock with type-safe configuration.\"\"\"\n    return QueueMessageMock(id=config.id, dequeue_count=config.dequeue_count)\n</code></pre> <p>Avoid:</p> <pre><code>def create_mock(config: dict[str, Any]) -&gt; QueueMessageMock:\n    \"\"\"Create mock without type safety.\"\"\"\n    return QueueMessageMock(id=config[\"id\"], dequeue_count=config[\"dequeue_count\"])\n</code></pre>"},{"location":"development/style-guide/#exception-azure-functions-sdk-compatibility","title":"Exception: Azure Functions SDK Compatibility","text":"<p>When interfacing with the Azure Functions SDK, match their API contracts exactly: - If the SDK expects <code>dict</code>, use <code>dict</code> - If the SDK returns <code>dict</code>, immediately convert to typed models for internal use</p> <pre><code>from dataclasses import dataclass\nimport typing as t\n\n@dataclass\nclass HttpRequestData:\n    \"\"\"Type-safe representation of HTTP request data.\"\"\"\n    method: str\n    url: str\n    headers: dict[str, str]\n\n    @classmethod\n    def from_sdk_request(cls, request: HttpRequest) -&gt; \"HttpRequestData\":\n        \"\"\"Convert from SDK type at boundary.\"\"\"\n        return cls(\n            method=request.method,\n            url=request.url,\n            headers=dict(request.headers),\n        )\n</code></pre>"},{"location":"development/style-guide/#test-naming-conventions","title":"Test Naming Conventions","text":"<ul> <li>Test function names must be descriptive and use lowercase with underscores.</li> <li>Test names should clearly state the scenario and expected outcome.</li> <li>Use the following pattern for test names:</li> </ul> <pre><code>test_&lt;unit_of_work&gt;_&lt;scenario&gt;_&lt;expected_result&gt;\n</code></pre> <p>Examples:</p> <ul> <li><code>test_queue_message_with_dict_body_serializes_to_json</code></li> <li><code>test_context_output_not_set_raises_value_error</code></li> <li> <p><code>test_http_mock_with_custom_headers_returns_correct_values</code></p> </li> <li> <p>Avoid generic names like <code>test_something</code> or <code>test_case1</code>.</p> </li> <li>The test name should make it clear what is being tested and what the expected behavior is.</li> </ul>"},{"location":"development/style-guide/#module-organization","title":"Module Organization","text":""},{"location":"development/style-guide/#domain-driven-module-structure","title":"Domain-Driven Module Structure","text":"<p>All modules should follow a consistent organization that prioritizes the \"need-to-know\" principle. Sections are ordered from most important (public API) to least important (implementation details).</p>"},{"location":"development/style-guide/#recommended-section-order","title":"Recommended Section Order","text":"<pre><code>\"\"\"Module docstring describing domain responsibility.\"\"\"\n\nfrom __future__ import annotations\n\n# =============================================================================\n# IMPORTS\n# =============================================================================\n# Standard library\nimport json\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass\nfrom datetime import datetime, timezone\n\n# Third-party\nfrom azure.functions import QueueMessage\n\n# Project/local\nfrom .base import BaseMock\n\n# =============================================================================\n# TYPES &amp; CONSTANTS\n# =============================================================================\nDEFAULT_MESSAGE_ID = \"test-message-id\"\nDEFAULT_DEQUEUE_COUNT = 1\n\n# =============================================================================\n# PUBLIC API\n# =============================================================================\ndef mock_queue_message(\n    body: dict | list | str | bytes | None = None,\n    *,\n    id: str | None = None,\n) -&gt; QueueMessageMock:\n    \"\"\"Create a mock QueueMessage for testing.\"\"\"\n    pass\n\n# =============================================================================\n# CORE CLASSES\n# =============================================================================\nclass QueueMessageMock(BaseMock[QueueMessage]):\n    \"\"\"Mock implementation of azure.functions.QueueMessage.\"\"\"\n    pass\n\n# =============================================================================\n# PRIVATE HELPERS\n# =============================================================================\ndef _serialize_body(body: dict | list | str | bytes) -&gt; bytes:\n    \"\"\"Convert various body types to bytes.\"\"\"\n    pass\n</code></pre>"},{"location":"development/style-guide/#rationale","title":"Rationale","text":"<ul> <li>Need-to-know: Readers see the module's interface immediately</li> <li>API-driven: Public functions define what the module does</li> <li>Top-down reading: Start with high-level concepts, drill down to implementation</li> <li>Maintainability: Easy to identify what can be refactored vs what's part of the public contract</li> <li>Consistency: Same pattern across all domain modules</li> </ul>"},{"location":"development/style-guide/#solid-principles-in-practice","title":"SOLID Principles in Practice","text":"<p>This library is explicitly designed around SOLID principles:</p>"},{"location":"development/style-guide/#single-responsibility-principle-srp","title":"Single Responsibility Principle (SRP)","text":"<ul> <li>Each mock class handles one trigger type (Queue, HTTP, Timer, etc.)</li> <li><code>FunctionTestContext</code> handles only output capture, not input mocking</li> <li>Factory functions handle only object creation, not behavior</li> </ul>"},{"location":"development/style-guide/#openclosed-principle-ocp","title":"Open/Closed Principle (OCP)","text":"<ul> <li><code>BaseMock</code> provides extension points for new mock types</li> <li>New trigger mocks extend <code>BaseMock</code> without modifying existing code</li> <li>Use abstract methods to enforce contracts</li> </ul>"},{"location":"development/style-guide/#liskov-substitution-principle-lsp","title":"Liskov Substitution Principle (LSP)","text":"<ul> <li>All mocks are drop-in replacements for real SDK types</li> <li>Duck-type compatibility: if <code>QueueMessage</code> has a method, our mock has it too</li> <li>Clients should not distinguish between real and mock objects</li> </ul>"},{"location":"development/style-guide/#interface-segregation-principle-isp","title":"Interface Segregation Principle (ISP)","text":"<ul> <li>Small, focused interfaces (e.g., <code>BaseMock._build()</code>, <code>BaseMock._default_values()</code>)</li> <li>Clients depend only on methods they use</li> <li>No \"fat interfaces\" with unused methods</li> </ul>"},{"location":"development/style-guide/#dependency-inversion-principle-dip","title":"Dependency Inversion Principle (DIP)","text":"<ul> <li>Depend on abstractions (<code>BaseMock</code>) not concrete implementations</li> <li>High-level modules (tests) don't depend on low-level modules (mock implementations)</li> </ul>"},{"location":"development/style-guide/#error-handling","title":"Error Handling","text":""},{"location":"development/style-guide/#fail-fast-fail-clear","title":"Fail Fast, Fail Clear","text":"<ul> <li>Validate inputs at function entry points</li> <li>Raise descriptive exceptions with actionable error messages</li> <li>Use built-in exception types when appropriate (<code>ValueError</code>, <code>TypeError</code>, <code>KeyError</code>)</li> </ul> <p>Good:</p> <pre><code>def mock_queue_message(body: dict | None = None) -&gt; QueueMessageMock:\n    \"\"\"Create a mock QueueMessage.\"\"\"\n    if body is not None and not isinstance(body, (dict, list, str, bytes)):\n        raise TypeError(\n            f\"body must be dict, list, str, or bytes, got {type(body).__name__}\"\n        )\n    return QueueMessageMock(body=body)\n</code></pre> <p>Avoid:</p> <pre><code>def mock_queue_message(body: dict | None = None) -&gt; QueueMessageMock:\n    \"\"\"Create a mock QueueMessage.\"\"\"\n    # Silently coerces or fails later with obscure error\n    return QueueMessageMock(body=body)\n</code></pre>"},{"location":"development/style-guide/#performance-guidelines","title":"Performance Guidelines","text":""},{"location":"development/style-guide/#optimization-principles","title":"Optimization Principles","text":"<ol> <li>Measure First: Always profile before optimizing</li> <li>Lazy Evaluation: Build mock objects only when accessed (see <code>BaseMock.build()</code>)</li> <li>Reuse Instances: Cache built mock instances to avoid redundant construction</li> <li>Simple is Fast: Prefer straightforward code; complexity rarely pays off in test utilities</li> </ol>"},{"location":"development/style-guide/#common-patterns","title":"Common Patterns","text":"<pre><code>class BaseMock:\n    \"\"\"Base mock with lazy build pattern.\"\"\"\n\n    def __init__(self, **overrides: Any) -&gt; None:\n        \"\"\"Initialize with config, but don't build yet.\"\"\"\n        self._values = {**self._default_values(), **overrides}\n        self._instance: T | None = None\n\n    def build(self) -&gt; T:\n        \"\"\"Build the mock instance lazily.\"\"\"\n        if self._instance is None:\n            self._instance = self._build()\n        return self._instance\n</code></pre>"},{"location":"development/style-guide/#git-commit-convention","title":"Git Commit Convention","text":"<ul> <li>Use clear, descriptive commit messages</li> <li>Follow the format: <code>&lt;type&gt;: &lt;description&gt;</code></li> <li>Types: <code>feat</code>, <code>fix</code>, <code>docs</code>, <code>style</code>, <code>refactor</code>, <code>test</code>, <code>chore</code></li> </ul> <p>Examples:</p> <ul> <li><code>feat: add ServiceBus mock support</code></li> <li><code>fix: handle None body in queue messages</code></li> <li><code>refactor: extract common validation logic to BaseMock</code></li> <li><code>docs: add examples for HTTP mock usage</code></li> <li><code>test: add edge case coverage for context output capture</code></li> </ul>"},{"location":"development/style-guide/#questions","title":"Questions?","text":"<p>If you're unsure about any style conventions, check this guide first. When in doubt: 1. Follow PEP 8 2. Prioritize type safety 3. Keep it simple (YAGNI - You Aren't Gonna Need It) 4. Match Azure Functions SDK conventions for compatibility</p>"}]}